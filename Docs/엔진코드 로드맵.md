## BVH2 만들기

- 이전 코드는 BVH에 사용되는 BBOX의 생명주기가 프로그램 시작 <-> 프로그램 종료까지 였다
  - = BBOX의 참조는 항상 유효하다, 심지어 정적이기 때문에 프로그램 시작 시 한번의 초기화로 모든 것이 잘 동작함
- 현재 코드는 BVH에 사용되는 BBOX의 생명주기가 불안정하다. 언제 삭제될 지 모른다
  - = BBOX의 참조는 유효할 수도 아닐 수도 있다.
  - 유효하지 않은 참조가 걸리면 위험하기 때문에 매 프레임 마다 참조가 있는 BBOX가 사라질 때 BVH의 트리를 한 번 업데이트 해줘야 한다.
  - 또한 신규 BBOX로 인해 참조가 추가될 때에도 BVH트리가 업데이트 되어야 한다.
  - 앞 선 규칙을 지켜서 Refit()과 Insert() Remove()를 모두 구현하여 동적 BVH 트리를 완성해야 함
  - 현재는 과제 코드이기 때문에 별도의 Object 없이 Transform을 참조하는 것으로 결정함
  - Transform에는 IsMatrixDirty()라는 항목이 존재하기 때문에 (심지어 parent-child 형태의 하이어라키 구조도 가지고 있음 ) 매 BVH체킹에서 해당 구문으로 BBOX의 이동이 필요한 친구들을 전부 마킹해서 처리할 수 있도록 해주는 것이 포인트



## Object API 완성

- 모든 객체를 표현하는 최상위 클래스
- 힙 메모리에 관해 일관적인 처리를 위해 만듬
- 현재 댕글링 포인터 방지를 위한 방법을 구상하고 있음



### | 댕글링 포인터 대안 |

#### > A안 

-  Object Handle을 구현하고 사용자가 Handle을 이용하게 하도록 강제



#### > B안

- C++내부의 RAII 구현을 최대한 이용하기 
  - 스마트 포인터를 적절히 이용하여 ObjectManager를 만들고 Weak 저장 Shared 배출 구조의 테이블을 구성해서 더 이상 참조하지 않는 Object는 자동 해제되게 보장 



#### > 공통 구현

- OnDisable(), OnDestroy() 이벤트 호출 시간에 무조건 Object로 구현한 Component가 살아있어야 함으로 ObjectManager나 어떤 레지스트리도 괜찮으니 지연파괴를 구현할 것, 그래서 Object를 파괴할 때 개념상으로만 파괴시키고 실제 로직에서는 프레임 처리 맨 마지막에 파괴처리할 것



## Object Serializer (JSON + RTTR)

- RTTR 라이브러리를 사용한 고수준 API
  - 런타임 타입 문자열 조회 능력을 이용하여 일관성 있는 코드를 제공함
- 파이썬 분석기 제작
  - 파이썬 코드로 빌드 파이프라인 초기 단계에 ScriptBehaviour(사용자 스크립트 코드)헤더를 전부 탐색해서 리플렉션에 필요한 코드를 자동 생성 시킴
  - 사용자가 직접 리플렉션을 구현하였다면 그 헤더는 스킵
    - (#define DONT_AUTOGEN_REFLECT_CODE 토큰 발견 시)
- 앞서 제작된 RTTR 코드를 전반적으로 이용하여 일관적인 META파일을 만듬
- 이 META파일과 리플렉션 코드는 에디터에서 IMGUI와 연동하여 사용할 예정임
- 추가적으로 Scene Rebuild에도 이 Serializer를 활용할 예정임
  - 시간이 더 된다면 Scene 객체를 만드는 팩토리 코드를 별도로 만들 수 있게 할 예정
  - 이 얘긴 즉슨 Player를 빌드할 때 Scene을 상속받은 객체코드를 새로 생성하고 Scene에서 요구하는 첫 초기화 코드 (하이어라키 복원)를 CPP 코드로 생성하여 Player DLL 내부에 넣어두고 마찬가지로 어떤 Scene이 플레이어에 들어가는지 알려주는 CPP 소스파일도 만들어서 main호출 할 때 이 Scene순서대로 로드시킬 예정



## Prefab

- 하이어라키의 구조(게임오브젝트 - 컴포넌트 - 리소스)를 직렬화한 데이터 = 하나의 파일단위
- 리소스 취급이며 prefab을 불러오면 GameObject로 전환됨
  - 전환되지 않고 여전히 prefab으로 취급하는 그 유니티용 기능은 차후에 만드는 것이 좋을 듯
- 모델 파일을 불러오면 Prefab으로 전환 시켜주는데, 컴포넌트에 들어가는 리소스로서 부착되는 형태이면 자동으로 리소스화 시켜줌 (Asset/Resource/[ Mesh, Texture , Material, AnimationClip ]에 만들어 줌)



## Resource Manager + GUID Helper

- 리소스는 GUID가 존재한다, 이것을 실제 런타임(엔진이든 플레이어든)에 사용하기 위해 경로와 리소스 GUID를 묶은 리소스테이블 파일이 존재함
  - Concrete 엔진에서 어떻게 만드는지 체크해둘 것



## 렌더 패스

- 기본적으로 아래와 같은 순서로 렌더패스가 구성됨
  - 포워드
    - 쉐도우맵
    - 스카이박스
    - Opaque -> Transparent ( 머터리얼 렌더패스 )
      - 문제가 있다면 현재 static, skinned에 대한 처리에 공통VS가 무조건 할당되어야 한다는 점임
      - Material은 VS,PS,GS,HS,DS를 모두 한번에 담아서 처리가 가능하기 때문에 하나의 렌더패스라고 봐도 무방한데 VS가 컴파일 분기든 아니면 할당 시 분기할당을 시키든 해서 skinned와 static을 분리해서 처리하는 로직이 꼭 필요함
    - 파티클 패스
    - 포스트 프로세싱
  - 디퍼드
    - 쉐도우맵
    - 스카이박스
    - 지오메트리 패스
      - 이거때문에 많이 고민함
      - 엔진에서 제공하는 모든 VS와 PS는 Forward <-> Deffered 렌더러간 교환이 쉽도록 진입점을 forward와 deffered로 분리 구현하였음
    - 라이트 패스  (Only Opaque - Material 패스)
      - Material API를 언급했지만 디퍼드 자체가 사실상 PBR을 위한 전용 패스으로 최적화될 가능성이 있음
      - 그래서 현재 라이트 패스는 PBR 단일 구현으로 진행됨
      - 추가로 블린퐁이나 스타일리쉬 패스를 추가하려면 지오메트리 패스와 Material API의 구조를 바꿔야 함
    - 포워드 패스  (Only Transparent - Material 패스)
      - 여기는 기존에 포워드 패스 함수에서 SetFlag를 오로지 Transparent로만 줘서 처리할 듯
    - 파티클 패스
    - 포스트 프로세싱
- 언급한 것처럼 Material API는 패스 중간에서 실제 메쉬 표면을 이용한 드로잉을 중점을 둬 작성하였음



## Vertex Shader Variant

- ILManager를 만든다
- GPU에 올릴 불변 정점 버퍼가 최대로 가질 수 있는 항목을 미리 정한다
  - pos
  - norm
  - tan
  - uv
  - boneIdx[4]
  - boneWeight[4]
- 모델을 임포팅하고 메쉬로 컨버팅할 때 메쉬는 아까 정해둔 항목 중 필요한 항목 만을 이용하여 파일 데이터(직렬화 가능한 구조)로 리소스화 시킴
- 나중에 실제 사용해야할 때 (프로그램 시작 시) 로드한 Mesh리소스는 불변 버퍼로 GPU 메모리에 올라감
- 이후 Renderer 클래스에서 Material에 할당된 셰이더 코드를 로드할 때 (특히 VS) 입력 레이아웃을 렌더러에 할당된 Mesh의 구조와 매칭시켜 만듬 (이미 있으면 참조만 가져옴) 
- 서로의 플래그가  [ VS ⊂ 메쉬 ] 인 경우 올바른 드로잉을 시도함
  - 아닌 경우 미리 정의된 셰이더로 두 가지 중에 하나를 출력
    - A : 정점데이터에 포지션 값을 가지고 있음 -> 표면전체를 Magenta { 1, 0, 1, 1 }로 메쉬 드로잉
    - B : 정점데이터에 포지션 값이 없음 -> 캐싱된 ERROR 모델 드로잉



## Dynamic Material Property

ShaderManager에서 Shader를 통합 관리하게 만들고 Shader Property로 구분되는 cbuffer를 실제 shader를 사용할 때 GPU에 만들어 보관해둔 뒤에 Material Property가 참조중인 셰이더를 모두 순회하면서 각 셰이더 스테이지 별로 필요한 ShaderProperty를 자신만의 MaterialProperty(CPU 데이터)로 바꿔 배열로 소지하고 있다가 Draw시에 ShaderBind



메쉬렌더러 <- 다양한 머터리얼을 넣을 수 있음, 머터리얼 마다 렌더링을 검